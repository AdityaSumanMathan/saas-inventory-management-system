const express = require('express');
const { body, query, validationResult } = require('express-validator');
const Stripe = require('stripe');
const db = require('../database');
const { authMiddleware, authorize } = require('../authMiddleware');

const router = express.Router();

// Initialize Stripe
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

// Subscription tier configurations
const SUBSCRIPTION_TIERS = {
  free: {
    name: 'Free',
    price: 0,
    features: {
      max_products: 100,
      max_users: 2,
      max_suppliers: 10,
      storage_gb: 1,
      api_calls_per_month: 1000,
      reporting: false,
      priority_support: false,
      advanced_features: false
    }
  },
  basic: {
    name: 'Basic',
    price: 29, // $29/month
    features: {
      max_products: 1000,
      max_users: 5,
      max_suppliers: 50,
      storage_gb: 5,
      api_calls_per_month: 10000,
      reporting: true,
      priority_support: false,
      advanced_features: false
    }
  },
  professional: {
    name: 'Professional',
    price: 79, // $79/month
    features: {
      max_products: 5000,
      max_users: 15,
      max_suppliers: 200,
      storage_gb: 25,
      api_calls_per_month: 50000,
      reporting: true,
      priority_support: true,
      advanced_features: true
    }
  },
  enterprise: {
    name: 'Enterprise',
    price: 199, // $199/month
    features: {
      max_products: -1, // unlimited
      max_users: -1, // unlimited
      max_suppliers: -1, // unlimited
      storage_gb: 100,
      api_calls_per_month: -1, // unlimited
      reporting: true,
      priority_support: true,
      advanced_features: true
    }
  }
};

// Get subscription plans
router.get('/plans', async (req, res) => {
  try {
    const plans = Object.entries(SUBSCRIPTION_TIERS).map(([key, tier]) => ({
      id: key,
      name: tier.name,
      price: tier.price,
      features: tier.features,
      price_id: process.env[`STRIPE_PRICE_${key.toUpperCase()}`] || null
    }));

    res.json({
      data: {
        plans
      }
    });

  } catch (error) {
    console.error('Get plans error:', error);
    res.status(500).json({ 
      error: 'Failed to fetch subscription plans', 
      message: error.message 
    });
  }
});

// Get current organization subscription
router.get('/current', authMiddleware, async (req, res) => {
  try {
    const organization = await db('organizations')
      .where('id', req.user.organization_id)
      .first();

    if (!organization) {
      return res.status(404).json({ 
        error: 'Organization not found' 
      });
    }

    // Get subscription details from Stripe if available
    let stripeSubscription = null;
    if (organization.stripe_subscription_id) {
      try {
        stripeSubscription = await stripe.subscriptions.retrieve(organization.stripe_subscription_id);
      } catch (error) {
        console.error('Error retrieving Stripe subscription:', error);
      }
    }

    const currentPlan = SUBSCRIPTION_TIERS[organization.subscription_tier] || SUBSCRIPTION_TIERS.free;

    res.json({
      data: {
        subscription: {
          tier: organization.subscription_tier,
          status: organization.subscription_status,
          trial_ends_at: organization.trial_ends_at,
          stripe_subscription_id: organization.stripe_subscription_id,
          current_period_start: stripeSubscription?.current_period_start,
          current_period_end: stripeSubscription?.current_period_end,
          cancel_at_period_end: stripeSubscription?.cancel_at_period_end
        },
        plan: currentPlan
      }
    });

  } catch (error) {
    console.error('Get current subscription error:', error);
    res.status(500).json({ 
      error: 'Failed to fetch current subscription', 
      message: error.message 
    });
  }
});

// Create Stripe checkout session
router.post('/checkout', authMiddleware, [
  body('price_id').notEmpty().withMessage('Price ID is required'),
  body('success_url').isURL().withMessage('Valid success URL is required'),
  body('cancel_url').isURL().withMessage('Valid cancel URL is required')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        error: 'Validation failed', 
        details: errors.array() 
      });
    }

    const { price_id, success_url, cancel_url } = req.body;

    // Get organization details
    const organization = await db('organizations')
      .where('id', req.user.organization_id)
      .first();

    if (!organization) {
      return res.status(404).json({ 
        error: 'Organization not found' 
      });
    }

    // Create or get Stripe customer
    let customerId = organization.stripe_customer_id;
    if (!customerId) {
      const customer = await stripe.customers.create({
        email: organization.email,
        name: organization.name,
        metadata: {
          organization_id: organization.id,
          organization_slug: organization.slug
        }
      });
      
      customerId = customer.id;
      
      // Update organization with Stripe customer ID
      await db('organizations')
        .where('id', organization.id)
        .update({ stripe_customer_id: customerId });
    }

    // Create checkout session
    const session = await stripe.checkout.sessions.create({
      customer: customerId,
      payment_method_types: ['card'],
      line_items: [
        {
          price: price_id,
          quantity: 1,
        },
      ],
      mode: 'subscription',
      success_url: success_url,
      cancel_url: cancel_url,
      metadata: {
        organization_id: organization.id,
        organization_slug: organization.slug
      },
      subscription_data: {
        metadata: {
          organization_id: organization.id,
          organization_slug: organization.slug
        }
      }
    });

    res.json({
      data: {
        checkout_url: session.url,
        session_id: session.id
      }
    });

  } catch (error) {
    console.error('Create checkout session error:', error);
    res.status(500).json({ 
      error: 'Failed to create checkout session', 
      message: error.message 
    });
  }
});

// Cancel subscription
router.post('/cancel', authMiddleware, authorize('admin'), async (req, res) => {
  try {
    const organization = await db('organizations')
      .where('id', req.user.organization_id)
      .first();

    if (!organization || !organization.stripe_subscription_id) {
      return res.status(400).json({ 
        error: 'No active subscription found' 
      });
    }

    // Cancel at period end (don't charge immediately)
    const subscription = await stripe.subscriptions.update(
      organization.stripe_subscription_id,
      {
        cancel_at_period_end: true
      }
    );

    await db('organizations')
      .where('id', organization.id)
      .update({ 
        updated_at: new Date()
      });

    res.json({
      message: 'Subscription will be cancelled at the end of the current billing period',
      data: {
        subscription
      }
    });

  } catch (error) {
    console.error('Cancel subscription error:', error);
    res.status(500).json({ 
      error: 'Failed to cancel subscription', 
      message: error.message 
    });
  }
});

// Resume subscription
router.post('/resume', authMiddleware, authorize('admin'), async (req, res) => {
  try {
    const organization = await db('organizations')
      .where('id', req.user.organization_id)
      .first();

    if (!organization || !organization.stripe_subscription_id) {
      return res.status(400).json({ 
        error: 'No active subscription found' 
      });
    }

    // Remove cancel at period end
    const subscription = await stripe.subscriptions.update(
      organization.stripe_subscription_id,
      {
        cancel_at_period_end: false
      }
    );

    await db('organizations')
      .where('id', organization.id)
      .update({ 
        updated_at: new Date()
      });

    res.json({
      message: 'Subscription has been resumed',
      data: {
        subscription
      }
    });

  } catch (error) {
    console.error('Resume subscription error:', error);
    res.status(500).json({ 
      error: 'Failed to resume subscription', 
      message: error.message 
    });
  }
});

// Update subscription plan
router.post('/update-plan', authMiddleware, authorize('admin'), [
  body('price_id').notEmpty().withMessage('Price ID is required')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        error: 'Validation failed', 
        details: errors.array() 
      });
    }

    const { price_id } = req.body;

    const organization = await db('organizations')
      .where('id', req.user.organization_id)
      .first();

    if (!organization || !organization.stripe_subscription_id) {
      return res.status(400).json({ 
        error: 'No active subscription found' 
      });
    }

    // Update subscription
    const subscription = await stripe.subscriptions.update(
      organization.stripe_subscription_id,
      {
        items: [
          {
            id: organization.stripe_subscription_id, // This should be the subscription item ID
            price: price_id,
          },
        ],
      }
    );

    res.json({
      message: 'Subscription plan updated successfully',
      data: {
        subscription
      }
    });

  } catch (error) {
    console.error('Update plan error:', error);
    res.status(500).json({ 
      error: 'Failed to update subscription plan', 
      message: error.message 
    });
  }
});

// Get subscription usage statistics
router.get('/usage', authMiddleware, async (req, res) => {
  try {
    const organizationId = req.user.organization_id;

    // Get current usage statistics
    const [productCount] = await db('products')
      .where('organization_id', organizationId)
      .where('is_active', true)
      .count('* as count');

    const [userCount] = await db('users')
      .where('organization_id', organizationId)
      .where('is_active', true)
      .count('* as count');

    const [supplierCount] = await db('suppliers')
      .where('organization_id', organizationId)
      .where('is_active', true)
      .count('* as count');

    // Get API calls for current month (you might want to implement an API logging system)
    const apiCallsThisMonth = 0; // Placeholder - implement actual API tracking

    const organization = await db('organizations')
      .where('id', organizationId)
      .first();

    const currentPlan = SUBSCRIPTION_TIERS[organization.subscription_tier] || SUBSCRIPTION_TIERS.free;

    res.json({
      data: {
        usage: {
          products: {
            current: parseInt(productCount.count),
            limit: currentPlan.features.max_products,
            percentage: currentPlan.features.max_products === -1 ? 0 : 
                        (parseInt(productCount.count) / currentPlan.features.max_products) * 100
          },
          users: {
            current: parseInt(userCount.count),
            limit: currentPlan.features.max_users,
            percentage: currentPlan.features.max_users === -1 ? 0 : 
                        (parseInt(userCount.count) / currentPlan.features.max_users) * 100
          },
          suppliers: {
            current: parseInt(supplierCount.count),
            limit: currentPlan.features.max_suppliers,
            percentage: currentPlan.features.max_suppliers === -1 ? 0 : 
                        (parseInt(supplierCount.count) / currentPlan.features.max_suppliers) * 100
          },
          api_calls: {
            current: apiCallsThisMonth,
            limit: currentPlan.features.api_calls_per_month,
            percentage: currentPlan.features.api_calls_per_month === -1 ? 0 : 
                        (apiCallsThisMonth / currentPlan.features.api_calls_per_month) * 100
          }
        },
        limits: currentPlan.features
      }
    });

  } catch (error) {
    console.error('Get usage error:', error);
    res.status(500).json({ 
      error: 'Failed to fetch usage statistics', 
      message: error.message 
    });
  }
});

// Webhook handler for Stripe events
router.post('/webhook', express.raw({ type: 'application/json' }), async (req, res) => {
  const sig = req.headers['stripe-signature'];
  let event;

  try {
    event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET);
  } catch (error) {
    console.error('Webhook signature verification failed:', error);
    return res.status(400).send(`Webhook Error: ${error.message}`);
  }

  try {
    switch (event.type) {
      case 'customer.subscription.created':
      case 'customer.subscription.updated':
        await handleSubscriptionUpdate(event.data.object);
        break;
      
      case 'customer.subscription.deleted':
        await handleSubscriptionDeleted(event.data.object);
        break;
      
      case 'invoice.payment_succeeded':
        await handlePaymentSucceeded(event.data.object);
        break;
      
      case 'invoice.payment_failed':
        await handlePaymentFailed(event.data.object);
        break;
      
      default:
        console.log(`Unhandled event type ${event.type}`);
    }

    res.json({ received: true });
  } catch (error) {
    console.error('Webhook handler error:', error);
    res.status(500).send('Webhook handler error');
  }
});

// Helper functions for webhook handling
async function handleSubscriptionUpdate(subscription) {
  const organizationId = subscription.metadata.organization_id;
  
  if (!organizationId) {
    console.error('No organization_id in subscription metadata');
    return;
  }

  // Determine subscription tier from price ID
  let tier = 'free';
  if (subscription.items && subscription.items.data.length > 0) {
    const priceId = subscription.items.data[0].price.id;
    
    // Map price IDs to tiers (customize based on your actual price IDs)
    const priceToTier = {
      'price_free': 'free',
      'price_basic': 'basic', 
      'price_professional': 'professional',
      'price_enterprise': 'enterprise'
    };
    
    tier = priceToTier[priceId] || 'free';
  }

  await db('organizations')
    .where('id', organizationId)
    .update({
      stripe_subscription_id: subscription.id,
      stripe_customer_id: subscription.customer,
      subscription_tier: tier,
      subscription_status: subscription.status,
      updated_at: new Date()
    });
}

async function handleSubscriptionDeleted(subscription) {
  const organizationId = subscription.metadata.organization_id;
  
  if (!organizationId) {
    console.error('No organization_id in subscription metadata');
    return;
  }

  await db('organizations')
    .where('id', organizationId)
    .update({
      stripe_subscription_id: null,
      subscription_tier: 'free',
      subscription_status: 'cancelled',
      updated_at: new Date()
    });
}

async function handlePaymentSucceeded(invoice) {
  const organizationId = invoice.metadata.organization_id;
  
  if (!organizationId) {
    console.error('No organization_id in invoice metadata');
    return;
  }

  await db('organizations')
    .where('id', organizationId)
    .update({
      subscription_status: 'active',
      updated_at: new Date()
    });
}

async function handlePaymentFailed(invoice) {
  const organizationId = invoice.metadata.organization_id;
  
  if (!organizationId) {
    console.error('No organization_id in invoice metadata');
    return;
  }

  await db('organizations')
    .where('id', organizationId)
    .update({
      subscription_status: 'past_due',
      updated_at: new Date()
    });
}

module.exports = router;